Lab Experiments
=============
	Circular Linked List Using two pointers (*head, *last)
	Circular Queue using Linked List
	Double Ended Que(DEQue) Using Single Linked List
	Priority Queue Using Single Linked List
	Polynomial Manipulations(Create, Addition, Multiplication and Display)
	Binary Search Tree(Insert, Delete, Search, Traversal)



Additional Experiments
=================
	Single Linked List
	Circular Linked List Using one pointer (*last)
	Queue using Arrays
	Circular Queues using Arrays
	Double Ended Que(DEQue) Using Double Linked List




-------------------------
Single Linked List
-------------------------
#include<stdio.h>
#include<stdlib.h>
struct node{
	int data;
	struct node* next;
}*head=NULL;
void create();
void insertBeg();
void insertEnd();
void insertPos();
void deleteBeg();
void deleteEnd();
void display();

void main()
{
	int ch;
	while(1)
	{
		printf("1.Create\n2.InsertBeg\n3.InsertEnd\n4.InsertAtPos\n5.DeleteBeg\n6.DeleteEnd\n7.Display\n8.Exit\n");
		printf("Enter your choice: \n");
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:create();
				break;
			case 2:insertBeg();
				break;
			case 3:insertEnd();
				break;
			case 4:insertPos();
				break;
			case 5:deleteBeg();
				break;
			case 6:deleteEnd();
				break;
			case 7:display();
				break;
			case 8:exit(0);
				break;
			default:printf("\nPlease enter valid option....\n");
		}
	}	
}

void create()
{
	int n,i;
	printf("\nEnter how many nodes you want to create: ");
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		struct node *n1;
		n1=(struct node*)malloc(sizeof(struct node));
		printf("\nEnter node%d data: ",i);
		scanf("%d",&n1->data);
		n1->next=NULL; 			

		if(head==NULL)
			head=n1;
		else
		{
			struct node *t;
			t=head;
			while(t->next!=NULL)
				t=t->next;
			t->next=n1;
		}
	}
}

void insertBeg()
{
	struct node *n1;
	n1=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter node data: ");
	scanf("%d",&n1->data);
	n1->next=head;
	head=n1;
}

void insertEnd()
{
	struct node *t,*n1;
	n1=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter node data: ");
	scanf("%d",&n1->data);
	n1->next=NULL;
	t=head;
	while(t->next!=NULL)
		t=t->next;
	t->next=n1;
}

void insertPos()
{
	int pos,i;
	struct node *n1,*t;
	printf("\nEnter position where you want to insert: ");
	scanf("%d",&pos);
	if(pos==1)
		insertBeg();
	else
	{
		n1=(struct node *)malloc(sizeof(struct node));
		printf("\nEnter node data: ");
		scanf("%d",&n1->data);
		t=head;
		for(i=2;i<pos;i++)
			t=t->next;
		n1->next=t->next;
		t->next=n1;
	}	
}

void deleteBeg()
{
	struct node *t;
	t=head;
	if(head==NULL)
		printf("\nList is empty....\n");
	else
	{
		printf("\nDeleted node data is:%d\n",t->data);
		head=head->next;
		free(t);	
	}
	
}

void deleteEnd()
{
	struct node *t;
	t=head;
	if(head==NULL)
		printf("\nList is empty....\n");
	else if(head->next==NULL)
	{
		printf("\nDeleted node data is:%d\n",head->data);
		head=NULL;
	}
	else
	{
		while(t->next->next!=NULL)
			t=t->next;
		printf("\nDeleted node data is:%d\n",t->next->data);
		t->next=NULL;	
	}
}

void display()
{
	struct node *t;
	t=head;
	if(head==NULL)
		printf("\nList is empty.....!\n");
	else
	{
		printf("\nList elements are: ");
		while(t->next!=NULL)
		{
			printf("%d--->",t->data);
			t=t->next;
		}
		printf("%d\n",t->data);
	}
}

-----------------------------------------------------------------------------
Circular Linked List Using two pointers (*head, *last)
------------------------------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
struct node{
	int data;
	struct node* next;
}*head=NULL,*last=NULL;
void create();
void insertBeg();
void insertEnd();
void insertPos();
void deleteBeg();
void deleteEnd();
void display();
struct node* createN();
void main()
{
	int ch;
	while(1)
	{
		printf("1.Create\n2.InsertBeg\n3.InsertEnd\n4.InsertAtPos\n5.DeleteBeg\n6.DeleteEnd\n7.Display\n8.Exit\n");
		printf("Enter your choice: \n");
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:create();
				break;
			case 2:insertBeg();
				break;
			case 3:insertEnd();
				break;
			case 4:insertPos();
				break;
			case 5:deleteBeg();
				break;
			case 6:deleteEnd();
				break;
			case 7:display();
				break;
			case 8:exit(0);
				break;
			default:printf("\nPlease enter valid option....\n");
		}
	}	
}

void create()
{
	int n, i;
	printf("\nEnter how many nodes you want to create: ");
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		struct node *newnode;
		newnode=(struct node*)malloc(sizeof(struct node));
		printf("\nEnter node %d data: ",i);
		scanf("%d",&nenode->data);
		if(head==NULL)
		{
			head=last=newnode;
			newnode->next=head;
		}
		else
		{
			newnode->next=head;
			last->next=nnewnode;
			last=newnode;
		}
	}
}

void insertBeg()
{
	struct node *newnode;
	newnode=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter node data: ");
	scanf("%d",&newnode->data);
	if(head==NULL)
	{
		head=last=newnode;
		newnode->next=head;
	}
	else
	{
		newnode->next=head;
		last->next=newnode;
		head=newnode;
	}	
}

void insertEnd()
{
	struct node *newnode;
	newnode=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter node data: ");
	scanf("%d",&newnode->data);
	if(head==NULL)
	{
		head=last=newnode;
		newnode->next=head;
	}
	else
	{
		newnode->next=last->next;
		last->next=newnode;
		last=newnode;
	}	
}

void insertPos()
{
	int pos,i;
	struct node *newnode,*temp;
	printf("\nEnter position where you want to insert: ");
	scanf("%d",&pos);
	if(pos==1)
		insertBeg();
	else
	{
		newnode=(struct node *)malloc(sizeof(struct node));
		printf("\nEnter node data: ");
		scanf("%d",&newnode->data);
		temp=head;
		for(i=2;i<pos;i++)
			temp=temp->next;
		newnode->next=temp->next;
		temp->next=newnode;
	}	
}

void deleteBeg()
{
	struct node *temp;
	temp=head;
	if(head==NULL)
		printf("\nList is empty.....\n");
	else if(head->next==head)
	{
		printf("\nDeleted node is: %d\n",temp->data);
		head=last=NULL;
		free(temp);
	}
	else
	{
		printf("\nDeleted node is: %d\n",temp->data);
		head=head->next;
		last->next=head;
		free(temp);
	}
	
}

void deleteEnd()
{
	struct node *temp=head,*prev;
	if(head==NULL)
		printf("\nList is empty.....\n");
	else if(head->next==head)
	{
		printf("\nDeleted node is: %d\n",head->data);
		head=last=NULL;
		free(temp);
	}
	else
	{
		while(temp->next!=head)
		{
			prev=temp;
			temp=temp->next;
		}
		prev->next=head;
		last=prev;
		printf("\nDeleted node is: %d\n",tem->data);
		free(temp);	
	}	
}

void display()
{
	struct node *temp;
	if(head==NULL)
		printf("\nList is empty.....!\n");
	else
	{
		temp=head;
		while(temp->next!=head)
		{
			printf("|%d|--->",temp->data);
			temp=temp->next;
		}
		printf("%d\n",temp->data);
	}
}

---------------------------------------------------------------
Circular Linked List Using one pointer (*last)
----------------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
struct node{
	int data;
	struct node* next;
}*last=NULL;
int c=0;
void create();
void insertBeg();
void insertEnd();
void insertPos();
void deleteBeg();
void deleteEnd();
void display();
struct node* newnode();
void main()
{
	int ch;
	while(1)
	{
		printf("1.Create\n2.InsertBeg\n3.InsertEnd\n4.InsertAtPos\n5.DeleteBeg\n6.DeleteEnd\n7.Display\n8.Exit\n");
		printf("Enter your choice: \n");
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:create();
				break;
			case 2:insertBeg();
				break;
			case 3:insertEnd();
				break;
			case 4:insertPos();
				break;
			case 5:deleteBeg();
				break;
			case 6:deleteEnd();
				break;
			case 7:display();
				break;
			case 8:exit(0);
				break;
			default:printf("\nPlease enter valid option....\n");
		}
	}	
}

struct node* newnode()
{
	struct node *n=(struct node *)malloc(sizeof(struct node));
	printf("\nEnter node data: ");
	scanf("%d",&n->data);
	n->next=NULL;
	return n;
}

void create()
{
	int n,i;
	printf("\nEnter how many nodes you want to create: ");
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		struct node *n1;
		n1=newnode();
		if(last==NULL)
		{
			last=n1;
			n1->next=last;
		}
		else
		{
			n1->next=last->next;
			last->next=n1;
			last=n1;
		}
		c++;
	}
}

void insertBeg()
{
	struct node *n1;
	n1=newnode();
	if(last==NULL)
	{
		last=n1;
		n1->next=last;
	}
	else
	{
		n1->next=last->next;
		last->next=n1;
	}	
	c++;
}

void insertEnd()
{
	struct node *n1,*t;
	n1=newnode();
	if(last==NULL)
	{
		last=n1;
		n1->next=last;
	}
	else
	{
		n1->next=last->next;
		last->next=n1;
		last=n1;
	}
	c++;	
}

void insertPos()
{
	int pos,i;
	struct node *n1,*t;
	printf("\nEnter position where you want to insert: ");
	scanf("%d",&pos);
	if(pos==1)
		insertBeg();
	else if(pos==c+1)
		insertEnd();
	else
	{
		n1=newnode();
		t=last->next;
		for(i=1;i<p-1;i++)
			t=t->next;
		n1->next=t->next;
		t->next=n1;	
		c++;
	}	
}

void deleteBeg()
{
	struct node *t,*t1;
	t=last->next;
	if(last==NULL)
		printf("\nList is empty.....\n");
	else if(last->next==last)
	{
		printf("\nDeleted node is: %d\n",last->data);
		last=NULL;
		free(t);
		c--;
	}
	else
	{
		printf("\nDeleted node is: %d\n",t->data);
		last->next=t->next;
		free(t);
		c--;
	}
	
}

void deleteEnd()
{
	struct node *t=last->next,*prev;
	if(last==NULL)
		printf("\nList is empty.....\n");
	else if(last->next==last)
	{
		printf("\nDeleted node is: %d\n",last->data);
		last=NULL;
		free(t);
		c--;
	}
	else
	{
		while(t->next!=last->next)
		{
			prev=t;
			t=t->next;
		}
		prev->next=last->next;
		last=prev;
		printf("\nDeleted node is: %d\n",t->data);
		free(t);	
		c--;
	}	
}

void display()
{
	struct node *t;
	printf("\nNo. of elements in Circular Linked List is: %d\n",c);
	if(last==NULL)
		printf("\nCircular Linked List is empty.....!\n");
	else
	{
		t=last->next;
		while(t->next!=last->next)
		{
			printf("%d--->",t->data);
			t=t->next;
		}
		printf("%d\n",t->data);
	}
}

------------------------------
Queue using Arrays
-------------------------------
#include<stdio.h>
#include<stdlib.h>
#define MAX 5
int q[MAX],front=-1,rear=-1;
void enque();
void deque();
void display();
void main()
{
	int ch;
	while(1)
	{
		printf("\n1.Enqueue\n2.Dequeue\n3.Display\n4.Exit\n");
		printf("\nEnter your choice: ");
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:enque();
				break;
			case 2:deque();
				break;
			case 3:display();
				break;
			case 4:exit(0);
				break;
			default:printf("\nPlease enter right chioce....\n");
		}
	}
}

void enque()
{
	if(rear==MAX-1)
		printf("\nQueue is full\n");
	else if(rear==-1)
	{
		rear=rear+1;
		front=front+1;
		printf("\nEnter data: ");
		scanf("%d",&q[rear]);
	}
	else
	{
		rear=rear+1;
		printf("\nEnter data: ");
		scanf("%d",&q[rear]);
	}
}

void deque()
{
	if(front==-1)
		printf("\nQueue is empty....\n");
	else if((front==rear)&front!=-1)
	{
		printf("\nDelete element is: %d",q[front]);
		front=rear=-1;
	}
	else
	{
		printf("\nDelete element is: %d",q[front]);
		front++;
	}
}

void display()
{
	if(front==-1)
		printf("\nQueue is empty....\n");
	else
	{
		int t=front;
		printf("\nQueue elements are: ");
		while(t!=rear+1)
		{
			printf("%3d",q[t]);
			t++;
		}
	}
}

------------------------------------------
Circular Queues using Arrays
------------------------------------------
#include<stdio.h>
#include<stdlib.h>
#define SIZE 5
int cqueue[SIZE];
int front=-1,rear=-1;
void insert();
void delete();
void display();
void main()
{
	while(1)
	{
		int c;
		printf("\n1.Insert");
		printf("\n2.Delete");
		printf("\n3.Display");
		printf("\n4.Exit");
		printf("\nEnter Your Choice: ");
		scanf("%d",&c);
		switch(c)
		{
			case 1:insert();
				break;
			case 2:delete();
				break;
			case 3:display();
				break;
			case 4:exit(0);
				break;
			default:printf("\nWrong Choice...!");
		}
	}
}

void insert()
{
	int ele;
	printf("\nEnter an element: ");
	scanf("%d",&ele);
	if(front==((rear+1)%SIZE))
		printf("\nQueue is full....!");
	else if(front==-1)
	{
		front=0;
		rear=rear+1;
		cqueue[rear]=ele;
	}
	else
	{
		rear=(rear+1)%SIZE;
		cqueue[rear]=ele;
	}
}

void delete()
{
	if(front==-1)
		printf("\nQueue is Empty....!");
	else if(front==rear)
	{
		printf("\nDeleted element is:%d",cqueue[front]);
		front=rear=-1;
	}
	else
	{
		printf("\nDeleted element is:%d",cqueue[front]);
		front=(front+1)%SIZE;
	}	
}

void display()
{
	if(front==-1)
		printf("\nQueue is Empty....!");
	else
	{
		int i=front;
		while(rear!=i)
		{
			printf("%d\t",cqueue[i]);
			i=(i+1)%SIZE;
		}
		printf("%d\t",cqueue[i]);
	}
}

----------------------------------------------
Circular Queue using Linked List
-----------------------------------------------
#include<stdio.h>
#include<stdlib.h>
struct node
{
	int data;
	struct node *next;
};
struct node *front=NULL,*rear=NULL;
void create();
void insert();
void delete();
void peek();
void display();
void main()
{
	int choice;
	while(1)
	{
		printf("\nCircular Queue Operations");
		printf("\n1. Create Circular Queue");
		printf("\n2. Insertion");
		printf("\n3. Deletion");
		printf("\n4. Peek");
		printf("\n5. Display");
		printf("\n6. Exit");
		printf("\nEnter your choice: ");
		scanf("%d",&choice);
		switch(choice)
		{
			case 1:create();
				break;
			case 2:insert();
				break;
			case 3:delete();
				break;
			case 4:peek();
				break;
			case 5:display();
				break;
			case 6:exit(0);
				break;
			default:printf("\nWrong choice....!");
		}
	}
}

void create()
{
	struct node *new;
	int ch,n,i;
/*     new=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter node data: ");
	scanf("%d",&new->data);
	front=rear=new;
	rear->next=front;
	printf("\nDo you want to create one more node? 1->yes	0->No");
	scanf("%d",&ch);
	while(ch)
	{
		struct node *new;
		new=(struct node*)malloc(sizeof(struct node));
		printf("\nEnter node data: ");
		scanf("%d",&new->data);
		rear->next=new;
		rear=new;
		rear->next=front;
		printf("\nDo you want to create one more node? 1->yes	0->No");
		scanf("%d",&ch);
	}      */
	printf("\nEnter how many nodes you want to create: ");
	scanf("%d",&n);
	for(i=0;i<n;i++)
	{
		new=(struct node*)malloc(sizeof(struct node));
		printf("\nEnter %d node data: ",i+1);
		scanf("%d",&new->data);
		if(front==NULL)
		{
			front=rear=new;
			rear->next=front;
		}
		else
		{
			new->next=rear->next;
			rear->next=new;
			rear=new;
		}
	}
}

void insert()
{
	struct node *new;
	new=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter node data: ");
	scanf("%d",&new->data);
	new->next=rear->next;
	rear->next=new;
	rear=new;
}

void delete()
{
	struct node *temp=front;
	if(front==NULL)
		printf("\nQueue is empty...!");
	else if(temp->next==front)
	{
		printf("\nDeleted element is:%d",temp->data);
		front=NULL;
		rear=NULL;
	}
	else
	{
		printf("\nDeleted element is:%d",temp->data);
		front=temp->next;
		rear->next=front;
		free(temp);
	}			
}

void peek()
{
	if(front==NULL)
		printf("\nQueue is empty...!");
	else
		printf("\nFront element is:%d",front->data);
}

void display()
{
	if(front==NULL)
		printf("\nQueue is empty...!");
	else
	{
		struct node *temp;
		temp=front;
		while(temp->next!=front)
		{
			printf("%d-->",temp->data);
			temp=temp->next;
		}
		printf("%d",temp->data);
	}
	
}

--------------------------------------------------------------------------
Double Ended Que(DEQue) Using Single Linked List
--------------------------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
struct node
{
	int data;
	struct node *next;
};
struct node *front=NULL,*rear=NULL;
void insertFront();
void insertRear();
void deleteFront();
void deleteRear();
void display();
void peekFront();
void peekRear();
void main()
{
	int c;
	while(1)
	{
		printf("\n1.Insert Front");
		printf("\n2.Insert Rear");
		printf("\n3.Delete Front");
		printf("\n4.Delete Rear");
		printf("\n5.Peek Front");
		printf("\n6.Peek Rear");
		printf("\n7.Display");
		printf("\n8.Exit");
		printf("\nEnter your choice: ");
		scanf("%d",&c);
		switch(c)
		{
			case 1:insertFront();
				break;
			case 2: insertRear();
				break;
			case 3:deleteFront();
				break;
			case 4: deleteRear();
				break;
			case 5: peekFront();
				break;
			case 6: peekRear();
				break;
			case 7: display();
				break;
			case 8: exit(0);
				break;
			default: printf("\nWrong Choice....!");
		}
	}
}

void insertFront()
{
	struct node *new;
	new=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter Node Data: ");
	scanf("%d",&new->data);
	new->next=NULL;
	if(front==NULL)
		front=rear=new;
	else
	{
		new->next=front;
		front=new;
	}
}

void insertRear()
{
	struct node *new;
	new=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter Node Data: ");
	scanf("%d",&new->data);
	new->next=NULL;
	if(front==NULL)
		front=rear=new;
	else
	{
		rear->next=new;
		rear=new;
	}
}

void deleteFront()
{
	struct node *temp=front;
	if(front==NULL)
		printf("\nQueue is empty....!");
	else if(front==rear)
	{
		printf("\nDeleted node is: %d\n",front->data);
		free(front);
		front=NULL;
		rear=NULL;
	}
	else
	{
		struct node *t;
		t=front;
		printf("\nDeleted node is: %d\n",t->data);
		front=front->next;
		free(t);
	}
}

void deleteRear()
{
	struct node *temp=rear;
	if(rear==NULL)
		printf("\nQueue is empty....!");
	else if(rear==front)
	{
		printf("\nDeleted node is: %d\n",rear->data);
		free(rear);
		front=NULL;
		rear=NULL;
	}
	else
	{
		struct node *t,*prev;
		t=front;
		while(t!=rear)
		{
			prev=t;
			t=t->next;
		}
		printf("\nDeleted node is: %d\n",t->data);
		rear=prev;
		free(t);
	}
}

void peekFront()
{
	if(front==NULL)
		printf("\nQueue is empty....!\n");
	else
		printf("\nFirst element in the Queue is:%d\n",front->data);
}

void peekRear()
{
	if(rear==NULL)
		printf("\nQueue is empty....!\n");
	else
		printf("\nLast/Rear element in the Queue is:%d\n",rear->data);
}

void display()
{
	struct node *temp;
	if(front==NULL)
		printf("\nQueue is empty....!");
	else
	{
		struct node *t;
		t=front;
		while(t!=rear)
		{
			printf("%d-->",t->data);
			t=t->next;
		}
		printf("%d",t->data);
	}
}

-----------------------------------------------------------------------------
Double Ended Que(DEQue) Using Double Linked List
-----------------------------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
struct node
{
	int data;
	struct node *prev;
	struct node *next;
}*front=NULL,*rear=NULL;
void enquefront();
void enquerear();
void dequefront();
void dequerear();
void peekfront();
void peekrear();
void displayforward();
void displaybackward();
void main()
{
	int ch;
	while(1)
	{
		printf("\n\nDouble Ended Queue Operations");
		printf("\n1. Enqueue At Front");
		printf("\n2. Enqueue At Rear");
		printf("\n3. Dequeue At Front");
		printf("\n4. Dequeue At Rear");
		printf("\n5. Peek Front");
		printf("\n6. Peek Rear");
		printf("\n7. Display Forward Direction");
		printf("\n8. Display Backword Direction");
		printf("\n9. Exit");
		printf("\nEnter your choice: ");
		scanf("%d",&ch);
		switch(ch)
		{
		case 1:enquefront();
				break;
		case 2:enquerear();
				break;
		case 3:dequefront();
				break;
		case 4:dequerear();
				break;
		case 5:peekfront();
				break;
		case 6:peekrear();
				break;
		case 7:displayforward();
				break;
		case 8:displaybackward();
				break;
		case 9:exit(0);
		default:printf("\nInvalid Option.....!");
		}
	}		
}

void enquefront()
{
	struct node *new=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter node data: ");
	scanf("%d",&new->data);
	new->next=new->prev=NULL;
	if((front==NULL)||(rear==NULL))
		front=rear=new;
	else
	{
		front->prev=new;
		new->next=front;
		front=new;
	}
}

void enquerear()
{
	struct node *new=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter node data: ");
	scanf("%d",&new->data);
	new->next=new->prev=NULL;
	if((front==NULL)||(rear==NULL))
		front=rear=new;
	else
	{
		rear->next=new;
		new->prev=rear;
		rear=new;
	}
}

void dequefront()
{
	struct node *temp=front;
	if(front==NULL)
		printf("\nDeQueue is empty....!");
	else if(front==rear)
	{
		front=rear=NULL;
		free(temp);
	}
	else
	{
		front=front->next;
		front->prev=NULL;
		free(temp);
	}
}

void dequerear()
{
	struct node *temp=rear;
	if(front==NULL)
		printf("\nDeQueue is empty....!");
	else if(front==rear)
	{
		front=rear=NULL;
		free(temp);
	}
	else
	{
		rear=rear->prev;
		rear->next=NULL;
		free(temp);
	}
}

void peekfront()
{
	if(front==NULL)
		printf("\nDeQueue is empty....!");
	else
		printf("|%d|",front->data);
}

void peekrear()
{
	if(rear==NULL)
		printf("\nDeQueue is empty....!");
	else
		printf("|%d|",rear->data);
}

void displayforward()
{
	if((front==NULL)||(rear==NULL))
		printf("\nDeQueue is empty....!");
	else
	{
		struct node *temp=front;
		while(temp->next!=NULL)
		{
			printf("|%d| ",temp->data);
			temp=temp->next;
		}
		printf("|%d|",temp->data);
	}
}

void displaybackward()
{
	if((front==NULL)||(rear==NULL))
		printf("\nDeQueue is empty....!");
	else
	{
		struct node *temp=rear;
		while(temp->prev!=NULL)
		{
			printf("|%d| ",temp->data);
			temp=temp->prev;
		}
		printf("|%d|",temp->data);
	}
}

--------------------------------------------------------
Priority Queue using Single Linked List
--------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
struct node
{
	int data;
	int priority;
	struct node *next;
};
struct node *front=NULL;
void insert();
void delete();
void peek();
void display();
void main()
{
	int c;
	while(1)
	{
		printf("\n1.Insert");
		printf("\n2.Delete");
		printf("\n3.Peek");
		printf("\n4.Display");
		printf("\n5.Exit");
		printf("\nEnter your choice: ");
		scanf("%d",&c);
		switch(c)
		{
			case 1: insert();
				break;
			case 2:delete();
				break;
			case 3: peek();
				break;
			case 4: display();
				break;
			case 5: exit(0);
				break;
			default: printf("\nWrong Choice....!");
		}
	}
}

void insert()
{
	struct node *node;
	node=(struct node*)malloc(sizeof(struct node));
	printf("\nEnter Node Data: ");
	scanf("%d",&node->data);
	printf("\nEneter Node Priority: ");
	scanf("%d",&node->priority);
	if((front==NULL)||(node->priority<front->priority))
	{
		node->next=front;
		front=node;
	}
	else
	{
		struct node *temp=front;
		while((temp->next!=NULL)&&(node->priority>=temp->next->priority))
			temp=temp->next;
		node->next=temp->next;
		temp->next=node;
	}	
}

void delete()
{
	struct node *temp=front;
	if(front==NULL)
		printf("\nQueue is empty....!");
	else
	{
		printf("\nDeleted element is:%d",temp->data);
		front=front->next;
		free(temp);
	}
}

void peek()
{
	if(front==NULL)
		printf("\nQueue is empty....!\n");
	else
		printf("\nFirst element in the Queue is:%d and it's Priority is:%d\n",front->data,front->priority);	
}

void display()
{
	struct node *temp;
	if(front==NULL)
		printf("\nQueue is empty....!");
	else
	{
		temp=front;
		while(temp!=NULL)
		{
			printf("%d|%d-->",temp->data,temp->priority);
			temp=temp->next;
		}
	}
}

--------------------------------------------------------------------------------------------------------
Polynomial Manipulations(Create, Addition, Multipliction and Display)
--------------------------------------------------------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
struct node
{
	int coeff;
	int expo;
	struct node *next;
};
struct node *create();
struct node *add(struct node *,struct node *);
void display(struct node *);

void main()
{
	struct node *p1,*p2,*mr;
	printf("\nFirst Polynomial Equation: ");
	p1=create();
	printf("\nSecond Polynomial Equation: ");
	p2=create();
	printf("\nFirst Polynomial Equation is: ");
	display(p1);
	printf("\nSecond Polynomial Equation is: ");
	display(p2);
	printf("\nAddition of Polynomial is: ");
	display(add(p1,p2));
	printf("\nMultiplication of Polynomial is: ");
	mr=mul(p1,p2)
	display(dup(mr));
}
struct node *create()
{
	int n,i;
	struct node *head=NULL,*last=NULL;
	printf("\nEnter no. of terms you want to create: ");
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		struct node *newnode=(struct node*)malloc(sizeof(struct node));
		printf("\nEnter Coefficient: ");
		scanf("%d",&newnode->coeff);
		printf("\nEnter Exponent: ");
		scanf("%d",&newnode->expo);
		newnode->next=NULL;
		if(head==NULL)
			head=last=newnode;
		else
		{
			last->next=newnode;
			last=newnode;
		}			
	}
	return head;
}

void display(struct node *p)
{
	struct node *temp=p;
	if(p==NULL)
		printf("\nNo Polynomial....!");
	else
	{
		while(temp->next!=NULL)
		{
			printf("%dX^%d+",temp->coeff,temp->expo);
			temp=temp->next;
		}
		printf("%dX^%d",temp->coeff,temp->expo);
	}
}

struct node *add(struct node *p1,struct node *p2)
{
	struct node *result,*temp;
	if((p1==NULL)&&(p2==NULL))
		printf("\nNo Equation.....!");
	else if((p1==NULL)&&(p2!=NULL))
		return p2;
	else if((p2==NULL)&&(p1!=NULL))
		return p1;
	else
	{
		result=(struct node*)malloc(sizeof(struct node));
		temp=result;
		while(p1&&p2)
		{
			if(p1->expo>p2->expo)
			{
				temp->coeff=p1->coeff;
				temp->expo=p1->expo;
				p1=p1->next;
			}
			else if(p1->expo<p2->expo)
			{
				temp->coeff=p2->coeff;
				temp->expo=p2->expo;
				p2=p2->next;
			}
			else
			{
				temp->coeff=p1->coeff+p2->coeff;
				temp->expo=p1->expo;
				p1=p1->next;
				p2=p2->next;
			}
			if(p1&&p2)
			{
				temp->next=(struct node*)malloc(sizeof(struct node));
				temp=temp->next;	
			}
		}
		while(p1)
		{
			temp->next=(struct node*)malloc(sizeof(struct node));
			temp=temp->next;
			temp->coeff=p1->coeff;
			temp->expo=p1->expo;
			p1=p1->next;
		}
		while(p2)
		{
			temp->next=(struct node*)malloc(sizeof(struct node));
			temp=temp->next;
			temp->coeff=p2->coeff;
			temp->expo=p2->expo;
			p2=p2->next;
		}
		temp->next=NULL;
	return result;
	}
}

/* With while */
------------------------
struct node *mul(struct node *p1,struct node *p2)
{
	struct node *res=NULL,*temp,*pt=p2;
	while(p1)
	{
		while(p2)
		{
			if(res==NULL)
			{
				res=(struct node*)malloc(sizeof(struct node));
				res->coeff=p1->coeff*p2->coeff;
				res->expo=p1->expo+p2->expo;
				p2=p2->next;
				temp=res;	
			}
			else
			{
				temp->next=(struct node*)malloc(sizeof(struct node));
				temp=temp->next;
				temp->coeff=p1->coeff*p2->coeff;
				temp->expo=p1->expo+p2->expo;
				p2=p2->next;
			}	
		}
		p1=p1->next;
		p2=pt;
	}
	temp->next=NULL;
	res=dup(res);
	return res;
}

struct node *dup(struct node *r)
{
	struct node *prev=r,*curr=r,*temp=r->next;
	while(curr)
	{
		while(temp)
		{
			if(curr->expo==temp->expo)
			{
				curr->coeff+=temp->coeff;
				prev->next=temp->next;
				free(temp);
				temp=prev->next;
			}
			else
			{
				prev=temp;
				temp=temp->next;
			}
		}
		curr=curr->next;
		prev=curr;
		temp=curr->next;
		if(curr->next==NULL)
			break;
	}
	return r;
}
/* With for */
--------------------
struct node *mul(struct node *p1,struct node *p2)
{
	struct node *res=NULL,*result,*pt=p2,*i,*j;
	res=(struct node*)malloc(sizeof(struct node));
	result=res;
	for(i=p1;i!=NULL;i=i->next)
	{
		for(j=p2;j!=NULL;j=j->next)
		{
			res->coeff=i->coeff*j->coeff;
			res->expo=i->expo+j->expo;
			if((i->next==NULL)&&(j->next==NULL))
				break;
			res->next=(struct node*)malloc(sizeof(struct node));
			res=res->next;	
		}
	}
	res->next=NULL;
	return dup(result);
}

struct term *dup(struct term *r)
{
	struct term *prev,*i,*j;
	for(i=r;i!=NULL;i=i->next)
	{
		if(i->next==NULL)
			break;
		prev=i;
		for(j=i->next;j!=NULL;j=j->next)
		{
			if(i->expo==j->expo)
			{
				i->coeff+=j->coeff;
				prev->next=j->next;
				free(j);
				j=prev;
			}
			else
				prev=prev->next;
		}
	}
	return r;
}

-------------------------------------------------------------------------
Binary Search Tree(Insert, Delete, Search, Traversal)
-------------------------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
struct node
{
	int data;
	struct node *left,*right;
}*root=NULL;
struct node *insert(struct node*,int);
struct node *delete(struct node*,int);
struct node *min(struct node*);
void search(struct node*,int );
void inorder(struct node*);
void preorder(struct node*);
void postorder(struct node*);
void main()
{
	int ch,ele;
	while(1)
	{
		printf("\nBinary Search Tree Operations\n");
		printf("================================");
		printf("\n1.Insert\n2.Delete\n3.Search\n4.Inorder Traversal\n5.Preorder Traversal\n6.Post order Traversal\n7.Exit");
		printf("\nEnter ur option: ");
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:printf("\nEnter an element: ");
				scanf("%d",&ele);
				root=insert(root,ele);
				break;
			case 2:printf("\nEnter an element to delete: ");
				scanf("%d",&ele);
				root=delete(root,ele);
				break;
			case 3:printf("\nEnter an element to search: ");
				scanf("%d",&ele);
				search(root,ele);
				break;
			case 4:inorder(root);
				break;
			case 5:preorder(root);
				break;
			case 6:postorder(root);
				break;
			case 7:exit(0);
			default:printf("\nPlease choose right chioce.....\n");
		}
	}
}

struct node *insert(struct node *r,int data)
{
	if(r==NULL)
	{
		struct node *t=(struct node*)malloc(sizeof(struct node));
		t->data=data;
		t->left=NULL;
		t->right=NULL;
		return t;
	}
	else if(data>r->data)
		r->right=insert(r->right,data);
	else if(data<r->data)
		r->left=insert(r->left,data);
	else
		return r;
	return r;
}

struct node *delete(struct node *t,int data)
{
	if(t==NULL)
		printf("\nDeleted Element %d is not found",data);
	else if(data>t->data)
	{
		t->right=delete(t->right,data);
	}
	else if(data<t->data)
		t->left=delete(t->left,data);
	else
	{
		if(t->left==NULL && t->right==NULL)
		{
			free(t);
			return NULL;
		}
		else if(t->left==NULL || t->right==NULL)
		{
			struct node *temp;
			if(t->left==NULL)
			{
				temp=t->right;
				free(t);
				return temp;
			}
			if(t->right==NULL)
			{
				temp=t->left;
				free(t);
				return temp;
			}
		}
		else
		{
			struct node *temp=min(t->right);
			t->data=temp->data;
			t->right=delete(t->right,temp->data);	
		}	
	}
	return t;
}

struct node *min(struct node *t)
{
	if(t->left==NULL)
		printf("\nMin is: %d",t->data);
	else
		min(t->left);
	return t;
}

void search(struct node *t,int data)
{
	if(t==NULL)
		printf("\nElement %d is not found",data);
	else if(t->data==data)
		printf("\nElement %d is found",t->data);
	else if(data>t->data)
		search(t->right,data);
	else 
		search(t->left,data);
}

void inorder(struct node *r)
{
	if(r!=NULL)
	{
		inorder(r->left);
		printf("%d\t",r->data);
		inorder(r->right);
	}	
}

void preorder(struct node *r)
{
	if(r!=NULL)
	{
		printf("%d\t",r->data);
		preorder(r->left);
		preorder(r->right);
	}	
}

void postorder(struct node *r)
{
	if(r!=NULL)
	{
		postorder(r->left);
		postorder(r->right);
		printf("%d\t",r->data);
	}	
}

